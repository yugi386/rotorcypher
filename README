RotorCipher V2
A Modern Stream Cipher with Dynamic Topological Mutation
   
RotorCipher V2 is a high-performance stream cipher written in Rust. It reimagines the structural complexity of classic mechanical rotor machines (such as the Enigma or Sigaba) by integrating them with modern cryptographic primitives, specifically SHA-3 sponge functions and Argon2id.
The core innovation of RotorCipher is Topological Mutation: unlike traditional stream ciphers with static shift registers, the internal architecture of this virtual machine (number of vectors, sizes, and positions) is deterministically constructed and unique for every seed.

--------------------------------------------------------------------------------
ðŸš€ Key Features
â€¢ Dynamic Bootstrapping: The rotor geometry is derived via a SHAKE256 oracle. Every key/nonce combination generates a unique machine topology using prime number vector lengths (range 300â€“10,000).
â€¢ Memory-Hard Key Derivation: Utilizes Argon2id (64 MiB, 3 iterations) to mitigate GPU/ASIC brute-force attacks on the password.
â€¢ Non-Linear Diffusion: Implements modular arithmetic (2^16 +1), inspired by the IDEA cipher, to mix rotor outputs before final generation.
â€¢ State Isolation: The final keystream is generated by an independent SHAKE256 instance, ensuring the internal rotor state cannot be algebraically reconstructed from the output.
â€¢ Authenticated Encryption: Follows the Encrypt-then-MAC paradigm using HMAC-SHA3-512 to ensure data integrity.
â€¢ Defense in Depth:
    â—¦ Side-Channel Resistance: Constant-time comparisons for MAC verification.
    â—¦ Memory Safety: Automatic clearing of sensitive secrets via the Zeroize trait.
    â—¦ SIMD Optimization: Explicit AVX2 and SSE2 implementation for high-speed XOR operations.

--------------------------------------------------------------------------------
âš™ï¸ Algorithm Architecture
1. Initialization (Forward Security)
The user secret and a nonce are processed by Argon2id to generate a 512-bit seed. This seed feeds a SHAKE256 oracle that defines the "physics" of the virtual machine:
â€¢ Prime Selection: Permutes a list of prime numbers based on the seed's entropy.
â€¢ Geometry Definition: Determines how many sub-vectors (17 to 32) constitute each of the 5 main rotors.
â€¢ State Filling: Populates the payload and initial cursor positions of every vector.
2. Keystream Generation (Backward Security)
The cycle to generate a 1024-byte keystream block involves:
1. Advance: Rotors step forward based on their distinct prime lengths.
2. Mixing: Outputs are combined via modular multiplication (m1 +m2 (mod256)).
3. Stochastic Extraction: A 5th control rotor dictates random "jumps" to fill a temporary entropy table T.
4. Expansion: Table T is hashed by a fresh SHAKE256 instance to produce the final keystream, isolating the internal state.

--------------------------------------------------------------------------------
ðŸ“¦ Installation & Usage
Add the dependency to your Cargo.toml:
[dependencies]
rotor_cipher = { path = "." }
Basic Example (In-Memory Encryption)
use rotor_cipher::{RotorCipher, RotorError};

fn main() -> Result<(), RotorError> {
    let password = b"super_secret_password";
    let (salt, nonce) = rotor_cipher::random_salt_nonce();

    // Initialize Cipher (Derivation + Dynamic Construction)
    let mut cipher = RotorCipher::new(password, &salt, &nonce)?;

    let mut data = b"Confidential message for HQ.".to_vec();
    println!("Original: {:?}", String::from_utf8_lossy(&data));

    // Encrypt in-place (XOR with keystream)
    cipher.apply_keystream_in_place(&mut data);
    println!("Encrypted: {:?}", data);

    // To decrypt, re-initialize with the same parameters
    let mut decipher = RotorCipher::new(password, &salt, &nonce)?;
    decipher.apply_keystream_in_place(&mut data);
    println!("Decrypted: {:?}", String::from_utf8_lossy(&data));

    Ok(())
}
File Encryption with Integrity
The library includes utilities for secure file handling, appending an HMAC-SHA3-512 tag:
use rotor_cipher::{cifrar_arquivo, decifrar_arquivo};

fn file_example() {
    let pass = b"my_strong_pass";
    let salt = [0u8; 16]; // Use random salt in production
    let nonce = [0u8; 16]; 

    // Generates "doc.txt.enc" containing [HMAC Tag + Ciphertext]
    cifrar_arquivo(pass, &salt, &nonce, "doc.txt").unwrap();

    // Verifies tag and restores to "doc.txt.enc.dec"
    decifrar_arquivo(pass, &salt, &nonce, "doc.txt.enc").unwrap();
}

--------------------------------------------------------------------------------
ðŸ›¡ï¸ Mathematical Security
â€¢ Period Magnitude: Since the virtual rotors are composed of vectors with distinct prime lengths (co-primes), the cycle period is the Least Common Multiple (LCM) of these lengths. This results in an astronomically large period (>300 
17 ), effectively preventing keystream reuse.
â€¢ Avalanche Effect: A single bit change in the seed alters the prime permutation and the number of vectors per rotor, resulting in a completely different machine topology (Gî€ =G) and internal state (Î£î€ =Î£).
ðŸ“„ License
This project is licensed under the MIT License. See the LICENSE file for details.

--------------------------------------------------------------------------------
Disclaimer: This software is an academic reference implementation based on the paper "RotorCipher: A Modern Approach to Rotor Ciphers Using Sponge Functions and Modular Arithmetic". While it employs robust standard primitives, please conduct a security audit before using it in critical production environments.
